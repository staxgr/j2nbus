
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class se_tap2_j2nbus_J2NBus */

#ifndef _Included_se_tap2_j2nbus_J2NBus
#define _Included_se_tap2_j2nbus_J2NBus
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     se_tap2_j2nbus_J2NBus
 * Method:    sendObjectToNative
 * Signature: (Ljava/lang/String;Ljava/lang/String;[B)V
 */
JNIEXPORT void JNICALL Java_se_tap2_j2nbus_J2NBus_sendObjectToNative
  (JNIEnv *, jclass, jstring, jstring, jbyteArray);

/*
 * Class:     se_tap2_j2nbus_J2NBus
 * Method:    init
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_se_tap2_j2nbus_J2NBus_init
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif


#pragma once
#include <jni.h>
#include <pthread.h>
#include <string>
#include <map>
#include "j2nbus_protocol.h"


JavaVM* jvm;


class ISubscriber {
public:
	virtual void onData(char* bytes) = 0;
};

template <class Data>
class Subscriber : public ISubscriber {
public:
	Subscriber(void (*sf)(Data)) {
		subscribeFunction = sf;
	}
	void onData(char* bytes) {
		Data data;
		data.fromBytes(bytes);
		subscribeFunction(data);
	}
private:
	void (*subscribeFunction)(Data);
};

class J2NBus {
private:
	JNIEnv *env;
	jclass cls;
	char* bytes;
	pthread_mutex_t mutex;

public:
    std::map<std::string, ISubscriber*> subscribers;

public:
	J2NBus(JNIEnv *env, jclass cls) {
		this->env = env;
		this->cls = (jclass) env->NewGlobalRef(cls);
		bytes = new char[32000];
		pthread_mutex_init(&mutex, NULL);
	}
	template <class Data>
	void subscribe(void (*sf)(Data)) {
		Subscriber<Data>* subscriber = new Subscriber<Data>(sf);
		std::string name = Data::getJavaClassName();
		subscribers[name] = subscriber;
	}


	template <class Data>
	void post(Data data) {

	    pthread_mutex_lock(&mutex);

	    JNIEnv *env;
        bool javaThread = true;

	    jvm->GetEnv((void**)&env, JNI_VERSION_1_4);

	    if(env == NULL) {
	        jvm->AttachCurrentThread(&env, NULL);
	        javaThread = false;
	    }

        /* start useful code*/


		jmethodID mID = env->GetStaticMethodID(cls, "onBytesFromNative", "(Ljava/lang/String;Ljava/lang/String;[B)V");

        int size = 0;
        std::string typeName = data.getJavaClassName();

        size += J2NProto::serialize(typeName, bytes);


		size += data.toBytes(bytes + size);

		jbyteArray bArray=env->NewByteArray(size);
		env->SetByteArrayRegion(bArray, 0, size, (jbyte *)bytes);


		env->CallStaticVoidMethod(cls, mID, NULL, NULL, bArray);

		env->DeleteLocalRef(bArray);

		/* end useful code */
		if(!javaThread) {
		    jvm->DetachCurrentThread();
		}
        //

        pthread_mutex_unlock(&mutex);

	}




};

void initBus(J2NBus* bus);

J2NBus* bus;


// The following two methods implement all the JNI we need for java -> native calls:

void Java_se_tap2_j2nbus_J2NBus_init
  (JNIEnv *env, jclass cls) {

	bus = new J2NBus(env, cls);

	initBus(bus);
}

void Java_se_tap2_j2nbus_J2NBus_sendObjectToNative
  (JNIEnv *env, jclass, jstring, jstring, jbyteArray bytes) {

	jboolean isCopy;
	jbyte* b = env->GetByteArrayElements(bytes, &isCopy);

    char* byteArray = (char*)b;
    int size = 0;

    std::string typeName;

    size += J2NProto::deserialize(&typeName, byteArray);

	ISubscriber* sub = bus->subscribers[typeName];

	if(sub != NULL) {
	    sub->onData(byteArray + size);
	} else {
	    __android_log_print(ANDROID_LOG_INFO, "MYPROG", "no subscriber for %s", typeName.c_str());
	}

	env->ReleaseByteArrayElements(bytes, b, 0);

}

jint JNI_OnLoad(JavaVM* aVm, void* aReserved)
{

    jvm = aVm;
	return JNI_VERSION_1_4;

};

